<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>ASP.NET Core webszolgáltatások I.-II.</title>
</articleinfo>
<section id="_kiegészítő_anyagok_segédeszközök">
<title>Kiegészítő anyagok, segédeszközök</title>
<itemizedlist>
<listitem>
<simpara>
kapcsolódó GitHub repo: <ulink url="https://github.com/bmeaut/WebApiLab">https://github.com/bmeaut/WebApiLab</ulink>
</simpara>
<itemizedlist>
<listitem>
<simpara>
elég csak <ulink url="https://github.com/bmeaut/WebApiLab/archive/refs/heads/master.zip">zip-ként letölteni</ulink>, nem kell klónozni
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
<ulink url="https://www.getpostman.com/">Postman</ulink> vagy <ulink url="https://www.telerik.com/download/fiddler">Fiddler Classic</ulink> HTTP kérések küldéséhez
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_kiinduló_projektek_beüzemelése">
<title>Kiinduló projektek beüzemelése</title>
<simpara>A kiinduló solution két .NET 6 osztálykönyvtárat foglal magába, melyek egy N-rétegű architektúra egy-egy rétegét valósítják meg:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">WebApiLab.Dal</emphasis>: lényegében az Entity Framework gyakorlatok anyagát tartalmazza, ez az adatelérési rétegünk.
</simpara>
<itemizedlist>
<listitem>
<simpara>
entitásdefiníciók
</simpara>
</listitem>
<listitem>
<simpara>
kontext, modellkonfigurációval, kezdeti adatokkal
</simpara>
</listitem>
<listitem>
<simpara>
connection string kezelés és SQL naplózás a korábbi gyakorlatok alapján
</simpara>
</listitem>
<listitem>
<simpara>
migráció (még) nincs
</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">WebApiLab.Bll</emphasis>: ezt szánjuk az üzleti logikai rétegnek. Fő feladata, hogy a DAL-ra építve végrehajtsa az <emphasis>Interfaces</emphasis> mappában definiált műveleteket.
</simpara>
<itemizedlist>
<listitem>
<simpara>
Interfaces - ez a BLL réteg specifikációja
</simpara>
</listitem>
<listitem>
<simpara>
Services - ide kerülnek majd az üzleti logikát, ill. az interfészeket megvalósító osztály(ok)
</simpara>
</listitem>
<listitem>
<simpara>
Dtos - csak később lesz szerepük, egyelőre nincsenek használva
</simpara>
</listitem>
<listitem>
<simpara>
Exceptions - saját kivétel osztály, egyelőre nincs használva
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Adjunk hozzá a solution-höz egy új C# nyelvű web API projektet (ASP.NET Core Web <emphasis role="strong">API</emphasis>, nem pedig Web App), a neve legyen <emphasis>WebApiLab.Api</emphasis>.</simpara>
<simpara>A következő dialógusablakban válasszuk ki a <emphasis>.NET 6</emphasis> opciót. Az extrák közül ne kérjük ezeket: HTTPS, Docker, authentikáció. Viszont hagyjuk bepipálva a Controller és az OpenAPI támogatást. A generált projektből törölhetjük a minta API fájljait, azaz a <emphasis>Weather</emphasis> kezdetű fájlokat a projekt gyökeréből és a <emphasis>Controllers</emphasis> mappából.</simpara>
<simpara>Adjuk hozzá függőségként:</simpara>
<itemizedlist>
<listitem>
<simpara>
a <emphasis>BLL</emphasis> projektet (menu:projekten jobbklikk[Dependencies &gt; Add Project Reference&#8230;])
</simpara>
</listitem>
<listitem>
<simpara>
a <emphasis>Microsoft.EntityFrameworkCore.Tools</emphasis> NuGet csomagot. Válasszunk olyan verziót, ami egyezik a DAL projekt Entity Framework Core függőségének verziójával.
</simpara>
</listitem>
</itemizedlist>
<warning><simpara>Olyan csomagoknál, ahol a verziószámozás követi az alap keretrendszer verziószámozását, törekedjünk arra, hogy a csomagok verziói konzisztensek legyenek egymással és a keretrendszer verziójával is - akkor is, ha egyébként a függőségi szabályok engednék a verziók keverését. Ha a projektünk például .NET 6-os keretrendszert használ, akkor az Entity Framework Core és egyéb extra ASP.NET Core csomagok közül is olyan verziót válasszunk, ahol legalább a főverzió egyezik, tehát valamilyen 6.x verziót. Ez nem azt jelenti, hogy az inkonzisztens verziók mindig hibát eredményeznek, inkább a projekt általában stabilabb, ha a főverziók közötti váltást egyszerre, külön migrációs folyamat (<ulink url="https://learn.microsoft.com/en-us/aspnet/core/migration/31-to-60">példa</ulink>) keretében végezzük.</simpara></warning>
</section>
<section id="_az_ef_bekötése_az_asp_net_core_di_naplózó_konfiguráló_rendszereibe">
<title>Az EF bekötése az ASP.NET Core DI, naplózó, konfiguráló rendszereibe</title>
<simpara>A kontext konfigurálása az EF gyakorlat során - mivel ott egy sima konzol alkalmazást írtunk - a kontext <literal>OnConfiguring</literal> függvényében történt. Mivel az ASP.NET Core projekt DI rendszert is ad, érdemes a kontextet a DI rendszerbe regisztrálni, hogy a projekten belül a modulok/osztályok függőségként tudják használni. A regisztrálás a legfelső szintű kódban történik (lásd ASP.NET Core bevezető gyakorlatot).</simpara>
<simpara>A kontext regisztrálása a legfelső szintű kódban a DI konténerbe:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">builder.Services.AddDbContext&lt;AppDbContext&gt;(o =&gt;
    o.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));</programlisting>
<simpara>Az EF naplózást az ASP.NET Core naplózó rendszere végzi, amit a kiinduló builder már inicializál, így ezzel kapcsolatban nincs teendőnk. Viszont egy új kontext konstruktorra lesz szükségünk, ami <literal>DbContextOptions&lt;AppDbContext&gt;</literal>-et vár.</simpara>
<simpara>A kontext <literal>OnConfiguring</literal>-jára pedig nincs szükség, úgyhogy töröljük ki, helyére tegyük az új konstruktort:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options)
    : base(options)
{
}</programlisting>
<simpara>Az Entity Framework gyakorlat alapján hozzunk létre egy új LocalDB adatbázist egy választott névvel, pl. neptun kód, northwind, stb. Az SQL Server Object Explorer-ből a connection string-et lopjuk el. (menu:nyissuk le az adatbáziskapcsolatot[jobbklikk az adatbázison &gt; Properties &gt; a Properties ablakból a <emphasis>Connection String</emphasis> értéke]).</simpara>
<simpara>Az <emphasis>appsettings.Development.json</emphasis>-ba vegyük fel a connection string-et és a generált SQL megfigyeléséhez a <emphasis>Microsoft</emphasis> kategóriájú naplók minimum szintjét csökkentsük <emphasis>Information</emphasis>-re.</simpara>
<programlisting language="javascript" linenumbering="unnumbered">/**/{
/**/  "Logging": {
/**/    "LogLevel": {
/**/      "Default": "Information",
          "Microsoft": "Information",
/**/    }
      }, //vessző bekerült
      "ConnectionStrings": {
         "DefaultConnection": "&lt;connection string&gt;"
      }
/**/}</programlisting>
<tip><simpara>Kukac (<literal>@</literal>) ilyenkor nem kell a connection string elé, mert ez JSON. Az adatbáziskapcsolatot azért kellhet lenyitni, hogy az SQL Server Object Explorer csatlakozzon is az új adatbázishoz, ezután tudjuk megszerezni a connection stringet.</simpara></tip>
<warning><simpara>A connection string különleges karaktereit a beillesztés után a VS alapesetben automatikusan escape-eli. Ha az automatikus escape-elés mégsem történik meg, manuálisan kell ezt megtennünk, különben <emphasis>A network-related or instance-specific error occurred while establishing a connection to SQL Server</emphasis> hibát kaphatunk.</simpara></warning>
<section id="_adatbázis_inicializálása_code_first_migrációval">
<title>Adatbázis inicializálása Code-First migrációval</title>
<simpara>Fordítsuk a teljes solution-t, állítsuk be indítandó (startup) projektnek az új Web API projektet (menu:jobbklikk a projekten[Set as Startup Project]). A <emphasis>Package Manager Console</emphasis>-t nyissuk meg, és állítsuk be Default Project-ként a DAL projektet. Készíttessük el a migrációt és futtassuk is le.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Add-Migration Init
Update-Database</programlisting>
<warning><simpara>Fontos, hogy a fenti parancs két projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet használó futtatható projektet. A VS Package Manager Console-jában futtatva alapértelmezésben az előbbit a Default Project értéke adja meg, utóbbit az indítandó projekt. Továbbá ezeket a projekteket meg lehet adni <ulink url="https://docs.microsoft.com/en-us/ef/core/miscellaneous/cli/powershell#common-parameters">paraméterként</ulink> is.</simpara></warning>
<tip><simpara>Itt mutatkozik meg, hogy a migráció lényegében egy teljes alkalmazásindítást jelent a <literal>Program</literal> osztályon keresztül: inicializálódik a DI konténer, a konfigurációs objektum stb.</simpara></tip>
<simpara>Ellenőrizzük az SQL Server Object Explorer-ben, hogy rendben lefutott-e a migráció, létrejöttek-e az adatbázis objektumok, feltöltődtek-e a táblák.</simpara>
</section>
</section>
<section id="_ef_entitások_használata_az_api_felületen">
<title>EF entitások használata az API felületen</title>
<simpara>Bár architektúra szempontból nem a legszebb, a BLL réteget gyakorlatilag mellőzve közvetlenül is használhatjuk az EF entitásokat a kontrollerek megvalósításánál. Ehhez használhatjuk a Visual Studio Entity Framework-ös Controller sablonjait.</simpara>
<simpara>Adjuk hozzá az API projekthez a <emphasis role="strong">Microsoft.VisualStudio.Web.CodeGeneration.Design</emphasis> NuGet csomagot. Válasszunk olyan verziót, ami egyezik a DAL projekt Entity Framework Core függőségének verziójával.</simpara>
<simpara>PMC-ben telepítsük az ASP.NET Core kódgeneráló eszközt</simpara>
<programlisting language="powershell" linenumbering="unnumbered">dotnet tool install -g dotnet-aspnet-codegenerator</programlisting>
<simpara>Majd lépjünk be a projekt könyvtárába</simpara>
<programlisting language="powershell" linenumbering="unnumbered">cd .\WebApiLab.Api</programlisting>
<simpara>Végül generáljunk a kódgenerálóval REST API (<literal>-api</literal>) kontrollert a <literal>Product</literal> entitáshoz (<literal>-m</literal>), mely az <literal>AppDbContext</literal> kontextushoz  (<literal>-dc</literal>) tartozik. A generált osztály neve legyen <literal>EFProductController</literal> (<literal>-name</literal>), a <literal>WebApiLab.Api.Controllers</literal> névtérbe  (<literal>-namespace</literal>) kerüljön. A generált fájl a <emphasis role="strong">Controllers</emphasis> mappába (<literal>-outDir</literal>) kerüljön.</simpara>
<programlisting language="powershell" linenumbering="unnumbered">dotnet aspnet-codegenerator controller -m WebApiLab.Dal.Entities.Product -dc WebApiLab.Dal.AppDbContext -outDir Controllers -name EFProductController -namespace WebApiLab.Api.Controllers -api</programlisting>
<warning><simpara>Figyeljünk rá, hogy <emphasis role="strong">ne</emphasis> a <literal>Dtos</literal> névtérből adjuk meg a DTO típust a tényleges entitástípus helyett.</simpara></warning>
<warning><simpara>A generálás során <emphasis>Unable to create an object of type <emphasis>AppDbContext</emphasis>.</emphasis> hibát kaphatunk. A hiba a kódgeneráló eszközben keresendő, a <ulink url="https://github.com/dotnet/Scaffolding/issues/1875">kapcsolódó GitHub issue-ban</ulink> találunk egy lehetséges megoldást is a problémára.</simpara></warning>
<simpara>A legenerálódó kontroller már használható is. Állítsuk át a zöld nyíl mellett az indítási konfigurációt a projektnevesre, hogy ne IIS Express induljon és így lássuk a konzolon a naplót. Indítsuk a projektet és próbáljuk például lekérni az összes terméket az <emphasis role="strong">api/efproduct</emphasis> címről vagy a Swagger felületről.</simpara>
<tip><simpara>Érdemes a zöld nyíl melletti lenyíló menüben olyan böngészőt megadni (Chrome, Firefox), ami értelmes formában meg tudja jeleníteni a nyers JSON adatokat, ha nem Swagger felületről tesztelünk.</simpara></tip>
<tip><simpara>Az alapértelmezésben megnyitandó URL útvonalat a projekt tulajdonságok között adhatjuk meg: menu:zöld nyíl melletti legördülő menü[&lt;Projektnév&gt; Debug Properties]. Ide egy a gyökércímhez képesti relatív útvonalrészt kell beírni. (pl. <emphasis>api/efproduct</emphasis>)</simpara></tip>
<simpara>Figyeljük meg, hogy a controller a konstruktorban igényli meg a DI-tól az EF kontextet, amit a szokásos módon osztályváltozóban tárol el.</simpara>
</section>
<section id="_köztes_réteg_alkalmazása">
<title>Köztes réteg alkalmazása</title>
<simpara>A rétegezett architektúra elveit követve gyakori eljárás, hogy a kontroller nem éri el közvetlenül az EF kontextet, hanem csak egy extra rétegen keresztül. A kontroller projekt így függetleníthető az EF modelltől.</simpara>
<simpara>Ehhez a megoldáshoz készítsünk külön kontroller változatot. A <emphasis>Controllers</emphasis> mappába hozzunk létre egy kontrollert (menu:Add[Controller &gt; bal fában Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <literal>ProductsController</literal> néven.</simpara>
<simpara>A BLL projekt Services mappájába hozzunk létre egy új osztályt <literal>ProductService</literal> néven. Az új osztály kontroller számára nyújtandó funkcióit az <literal>IProductService</literal> adja meg. Implementáljuk ezt az interfészt, a kiinduló implementációt generáltassuk a Visual Studio-val. Konstruktorban várja a függőségként a kontextet. A kontext segítségével implementáljuk normálisan a <literal>GetProducts</literal> függvényt. <emphasis>Eager Loading</emphasis> használatával az egyes termékekhez a kapcsolódó kategóriát és megrendeléseket is adjuk vissza.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public class ProductService : IProductService
{
    private readonly AppDbContext _context;

    public ProductService(AppDbContext context)
    {
        _context = context;
    }

    public IEnumerable&lt;Product&gt; GetProducts()
    {
        var products = _context.Products
            .Include(p =&gt; p.Category)
            .Include(p =&gt; p.ProductOrders)
                .ThenInclude(po =&gt; po.Order)
            .ToList();

        return products;
    }
    /*Többi függvény generált implementációja*/
}</programlisting>
<simpara>Injektáljunk <literal>IProductService</literal>-t a <literal>ProductsController</literal>-be.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">private readonly IProductService _productService;

public ProductsController(IProductService productService)
{
    _productService = productService;
}</programlisting>
<simpara>Adjuk meg a DI alrendszernek, hogy hogyan kell egy <literal>IProductService</literal> típusú függőséget létrehozni. A legfelső szintű kódba:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">builder.Services.AddTransient&lt;IProductService, ProductService&gt;();</programlisting>
<simpara>A függőséginjektálás úgy működik, hogy a kontrollereket is a központi DI komponens példányosítja, és ilyenkor megvizsgálja a konstruktor paramétereket. Ha a konténerben talál alkalmas beregisztrált osztályt, akkor azt létrehozza és átadja a konstruktornak. Ezt hívjuk konstruktor injektálásnak. Ha a létrehozandó függőségnek is vannak konstruktor paraméterei, akkor azokat is megpróbálja feloldani, így rekurzívan a teljes függőségi objektum hierarchiát le tudja kezelni (ha abban nincs irányított kör). Ezt hívjuk autowiring-nek.</simpara>
<simpara>A regisztráció során több lehetőségünk is van. Egyrészt nem kötelező interfészt megadni egy osztály beregisztrálásához, az osztályt önmagában is be lehet regisztrálni, ilyenkor a konstruktorban is osztályként kell elkérni a függőségeket.</simpara>
<simpara>Háromféle példányosítási stratégiával regisztrálhatjuk be az osztályainkat:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">Transient</emphasis>: minden egyes injektálás során új példány jön létre
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Scoped</emphasis>: HTTP kérésenként egy példány kerül létrehozásra és a kérésen belül mindenkinek ez lesz injektálva
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Singleton</emphasis>: mindenkinek ugyanaz az egy példány kerül átadásra kéréstől függetlenül
</simpara>
</listitem>
</itemizedlist>
<simpara>Írjunk új <literal>Get()</literal> változatot az eredeti helyett a <literal>ProductsController</literal>-be az <literal>IProductService</literal> függőséget felhasználva:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">[HttpGet]
public IEnumerable&lt;Product&gt; Get()
{
    return _productService.GetProducts();
}</programlisting>
<simpara>Próbáljuk ki (<literal>api/products</literal>). Hibát kapunk, mert a <literal>ProductService</literal> lekérdező függvénye eager loading-gal (<literal>Include</literal>) navigációs property-ket is kitölt, így könnyen hivatkozási kör jön létre, amit a JSON sorosító alapértelmezésben kivétellel jutalmaz. A sorosítást a keretrendszer végzi, a kontrollerfüggvény visszatérési értékét sorosítja a HTTP tartalomegyeztetési szabályok szerint. Böngésző kliens esetén alapesetben a JSON formátum lesz a befutó. Persze a sorosítás ennél közvetlenebbül is <ulink url="https://docs.microsoft.com/en-us/aspnet/core/web-api/advanced/formatting">konfigurálható</ulink>, ha szükséges.</simpara>
<simpara>A kontrollerek által használt JSON sorosítót konfigurálhatjuk a legfelső szintű kódban, például beállíthatjuk, hogy ha egy objektumot már korábban sorosított, akkor csak hivatkozzon rá és ne sorosítsa újra.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/builder.Services.AddControllers() //; törölve
    .AddJsonOptions(o =&gt; o.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.Preserve);</programlisting>
<simpara>Így már sikerülni fog a sorosítás, egy elég furcsa JSON-t láthatunk, ahol az első elem egy nagyobb objektumgráfot leíró rész, a többi elem pedig csak hivatkozás.</simpara>
<simpara>Ennek a megoldásnak a hátránya, hogy a kliensoldali sorosítónak is támogatnia kell ezt a sorosítási logikát, a JSON-on belüli kereszthivatkozások kezelését.</simpara>
<simpara>Emiatt kommentezzük is ki ezt a beállítást, keressünk más megoldást.</simpara>
</section>
<section id="_dto_osztályok">
<title>DTO osztályok</title>
<simpara>Láthattuk, hogy az entitástípusok közvetlen sorosítása gyakran nehézségekbe ütközik. A modell kifejezetten az EF számára lett megalkotva, illetve hogy a lekérdező műveleteket minél kényelmesebben végezhessük. A kliensoldal számára érdemes külön modellt megalkotni, egy ún. DTO (<emphasis>Data Transfer Object</emphasis>) modellt, ami a kliensoldal igényeit veszi figyelembe: <emphasis role="strong">pontosan</emphasis> annyi adatot és <emphasis role="strong">olyan szerkezetben</emphasis> tartalmaz, amire a kliensnek szüksége van.</simpara>
<simpara>A <emphasis>BLL</emphasis> projektben jelenleg egy nagyon egyszerű DTO modell található a <emphasis>Dtos</emphasis> mappában:</simpara>
<itemizedlist>
<listitem>
<simpara>
rekord típusok alkotják a modellt
</simpara>
</listitem>
<listitem>
<simpara>
nincs benne minden navigációs property, pl. <literal>Category.Products</literal>
</simpara>
</listitem>
<listitem>
<simpara>
nincs benne a kapcsolótáblát reprezentáló entitás
</simpara>
</listitem>
<listitem>
<simpara>
a termékből közvetlenül elérhetők a megrendelések
</simpara>
</listitem>
</itemizedlist>
<simpara>A különféle modellek közötti leképezésnél jól jönnek az ún. <emphasis>object mapper</emphasis>-ek, melyek segítenek elkerülni a leképezésnél nagyon gyakori repetitív kódokat, mint amilyen az <literal>x.Prop = y.Prop</literal> jellegű propertyérték-másolgatás.</simpara>
<simpara>Adjuk hozzá az API projekthez az <emphasis>AutoMapper.Extensions.Microsoft.DependencyInjection</emphasis> csomagot, a BLL projekthez pedig az <emphasis>AutoMapper</emphasis> csomagot.</simpara>
<simpara>A leképezési konfigurációkat profilokba szervezve adhatjuk meg. Adjunk hozzá a BLL projekthez egy új osztályt <literal>WebApiProfile</literal> néven a <emphasis>Dtos</emphasis> mappába. Az AutoMapper konvenció alapon működik, tehát a DTO-entitás párokon kívül nem kell megadni például egyesével a property- vagy konstruktorparaméter-leképezéseket, ha a nevek alapján a leképezés kikövetkeztethető. Külön konfigurálásra csak a nem-triviális esetekben van szükség.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">using AutoMapper;

namespace WebApiLab.Bll.Dtos;

public class WebApiProfile : Profile
{
    public WebApiProfile()
    {
        CreateMap&lt;Dal.Entities.Product, Product&gt;().ReverseMap();
        CreateMap&lt;Dal.Entities.Order, Order&gt;().ReverseMap();
        CreateMap&lt;Dal.Entities.Category, Category&gt;().ReverseMap();
    }
}</programlisting>
<simpara>A DI konténerhez adjuk hozzá és konfiguráljuk a leképezési szolgáltatást.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">builder.Services.AddAutoMapper(typeof(WebApiProfile));</programlisting>
<tip><simpara>Az AutoMapper az <literal>AddAutoMapper</literal> paramétereként megadott típust definiáló szerelvényben fogja a profilt keresni. A konkrét típusnak nincs más jelentősége, nem kell feltétlenül profilnak lenni.</simpara></tip>
<simpara>Injektáltassuk be a leképzőt reprezentáló <literal>IMapper</literal> típusú objektumot a <literal>ProductService</literal>-be.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/private readonly AppDbContext _context;
    private readonly IMapper _mapper;
/**/
/**/public ProductService(AppDbContext context
                        , IMapper mapper)
/**/{
/**/    _context = context;
        _mapper = mapper;
/**/}</programlisting>
<simpara>A <literal>ProductsController</literal>-ben, az <literal>IProductService</literal>-ben és a <literal>ProductService</literal>-ben az entitásokra mutató névteret cseréljük ki a DTO-kra mutatóra:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">//using WebApiLab.Dal.Entities;
using WebApiLab.Bll.Dtos;</programlisting>
<simpara>Írjuk át a lekérdezést a <literal>ProductService</literal>-ben a leképzőt alkalmazva:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public IEnumerable&lt;Product&gt; GetProducts()
/**/{
/**/    var products = _context.Products
            .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)
            .AsEnumerable();
/**/    return products;
/**/}</programlisting>
<simpara>Hogy ne zavarjanak be a Swaggernek az <literal>EFProductController</literal>-ben használt entitás osztályok, töröljük ki a Controllers mappából az <literal>EFProductController</literal>-t!</simpara>
<simpara>Próbáljuk ismét meghívni böngészőből, figyeljük meg a naplóban, hogy milyen SQL lekérdezés fut le.</simpara>
<tip><simpara>A többrétegű architektúránál elméletben minden rétegnek külön objektummodellje kellene, hogy legyen DAL: EF entitások, BLL: <ulink url="https://en.wikipedia.org/wiki/Domain_model">domain objektumok</ulink>, Kontroller: DTO-k, viszont ha a domain objektumok nem visznek plusz funkciót a rendszerbe, akkor el szoktuk hagyni.</simpara></tip>
<simpara>A DTO leképezést más rétegben is végezhetnénk. Egyes megközelítések szerint a kontroller réteg feladata lenne, azonban, ha az EF lekérdezésekkel összevonva végezzük a leképezést, akkor kiaknázhatjuk a <emphasis>query result shaping</emphasis> előnyeit, azaz csak azt kérdezzük le az adatbázisból, amire a leképezésnek szüksége van. Az AutoMapper <literal>ProjectTo</literal> függvénye ráadásul mindezt el is intézi helyettünk a leképezési konfiguráció alapján.</simpara>
<tip><simpara>A <literal>ProjectTo</literal> speciálisan <literal>IQueryable</literal>-en működik. Ha csak simán memóriabeli objektumok között szeretnénk leképezni, akkor az <literal>IMapper</literal> <literal>Map&lt;&gt;</literal> függvényét hívjuk. A memóriabeli  leképezésnek hátránya, hogy EF szinten gondoskodnunk kell róla, hogy <literal>Include</literal> hívásokkal a leképezéshez szükséges kapcsolódó entitásokat is lekérdezzük. A <literal>ProjectTo</literal> ezt is elintézi helyettünk.</simpara></tip>
<simpara>A <literal>ProjectTo</literal> metódust felfoghatjuk a továbbiakban egy LINQ-s <literal>Select()</literal> operátornak, annyi különbséggel, hogy az AutoMapper generálja azt az <literal>Expression</literal>-t, ami alapján előáll majd az eredmény.</simpara>
</section>
<section id="_bll_funkciók_implementációja">
<title>BLL funkciók implementációja</title>
<section id="_egy_elem_lekérdezése">
<title>Egy elem lekérdezése</title>
<simpara>Valósítsunk meg további interfész által előírt funkciókat a <literal>ProductService</literal> osztályban:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public Product GetProduct(int productId)
/**/{
        return _context.Products
            .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)
            .SingleOrDefault(p =&gt; p.Id == productId)
            ?? throw new EntityNotFoundException("Nem található a termék");
/**/}</programlisting>
</section>
<section id="_beszúrás">
<title>Beszúrás</title>
<simpara>Ez hasonló az EF gyakorlaton látottakhoz, csak itt nem kell legyártanunk az új <literal>Product</literal> példányt, paraméterként kapjuk és memóriában leképezzük az enititásra. A <literal>SaveChanges</literal> hívás után a kulcs értéke már ki lesz töltve (adatbázis osztja ki a kulcsot).</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public Product InsertProduct(Product newProduct)
/**/{
        var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(newProduct);
        _context.Products.Add(efProduct);
        _context.SaveChanges();
        return GetProduct(efProduct.Id);
/**/}</programlisting>
</section>
<section id="_módosítás">
<title>Módosítás</title>
<simpara>Konvenció szerint külön paraméterként szokták átadni a módosítandó elem azonosítóját és az új értékeket összefogó példányt. Leképezés után összeállítunk egy olyan entitás példányt, mint amilyet az adatbázisból kérdeztünk volna le - viszont ez a példány nem lesz a kontext látókörében. Az <literal>Attach</literal> függvény hasonló az <literal>Add</literal>-hoz, hozzáadja a kontext nyilvántartásához a példányt, de az <literal>Attach</literal> alapesetben nem jelöli meg a státuszt, marad változatlan (<emphasis>Unchanged</emphasis>). Explicit megjelöljük változottként, a változást végül a <literal>SaveChanges</literal> érvényesíti.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public void UpdateProduct(int productId, Product updatedProduct)
/**/{
        var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(updatedProduct);
        efProduct.Id = productId;
        _context.Attach(efProduct).State = EntityState.Modified;
        _context.SaveChanges();
/**/}</programlisting>
<tip><simpara>Alternatíva lehetne még ennél a függvénynél, hogy lekérdezzük azonosító (<literal>Id</literal>) alapján az entitást és AutoMapperrel a lekérdezett objektumba mappeljük a DTO-t. Ebben az esetben nincs szükség <literal>Attach</literal>-ra és állapotkezelésre sem, viszont extra lekérdezéssel jár.</simpara></tip>
</section>
<section id="_törlés">
<title>Törlés</title>
<simpara>Egy trükkel elkerülhetjük, hogy le kelljen kérdezni a törlendő terméket. Az azonosító alapján előállítunk memóriában egy példányt a megfelelő kulccsal, majd <literal>Remove</literal> függvénnyel hozzáadjuk a kontexthez. A <literal>Remove</literal> törlendőnek jelöli a példányt.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public void DeleteProduct(int productId)
/**/{
        _context.Products.Remove(new Dal.Entities.Product(null!) { Id = productId });
        _context.SaveChanges();
/**/}</programlisting>
</section>
</section>
<section id="_rest_konvenciók_alkalmazása">
<title>REST konvenciók alkalmazása</title>
<simpara>A REST megközelítés nem csak átviteli közegnek tekinti a HTTP-t, hanem a protokoll részeit felhasználja, hogy kiegészítő információkat vigyen át. Emiatt előnyös lenne, ha nagyobb ellenőrzésünk lenne a HTTP válasz felett - szerencsére az ASP.NET Core biztosítja ehhez a megfelelő API-kat.</simpara>
<simpara>Egyik legegyszerűbb ilyen irányelv, hogy a lekérdezések eredményeként, ha megtaláltuk és visszaadtuk a kért adatokat, akkor <emphasis role="strong">200 (OK)</emphasis> HTTP válaszkódot adjunk.</simpara>
<tip><simpara>A HTTP kérést érintő irányelvekről egy jó összefoglaló elérhető <ulink url="https://www.restapitutorial.com/lessons/httpmethods.html">itt</ulink>.</simpara></tip>
<simpara>Az eddig megírt <literal>Get()</literal> függvényünk most is <emphasis role="strong">200 (OK)</emphasis>-ot ad, ezt le is ellenőrizhetjük a böngészőnk hálózati monitorozó eszközében.</simpara>
<tip><simpara>A HTTP kommunikáció megfigyelésére használhatjuk a böngészők beépített eszközeit, mint amilyen a <ulink url="https://developer.mozilla.org/en-US/docs/Tools">Firefox Developer Tools</ulink>, illetve <ulink url="https://developers.google.com/web/tools/chrome-devtools/">Chrome DevTools</ulink>. Általában az kbd:[F12] billentyűvel aktiválhatók. Emellett, ha egy teljesértékű HTTP kliensre van szükségünk, amivel például könnyen tudunk nem csak GET kéréseket küldeni, akkor a <ulink url="https://www.getpostman.com/">Postman</ulink> és a <ulink url="https://www.telerik.com/download/fiddler">Fiddler Classic</ulink> külön telepítendő eszközök ajánlhatók. A Fiddler mint proxy megoldás egy Windows gépen folyó HTTP kommunikáció megfigyelésére is alkalmas.</simpara></tip>
<simpara>Első körben a két lekérdező függvényt írjuk át úgy, hogy a HTTP válaszkódokat explicit megadjuk. A jelenlegi legmodernebb mód ehhez az <literal>ActionResult&lt;&gt;</literal> használata. Elég <literal>T</literal>-t visszaadnunk a függvényben, automatikusan <literal>ActionResult&lt;T&gt;</literal> típussá konvertálódik. Tehát elvileg írhatnánk ezt:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">//NEM FORDUL!
/**/[HttpGet]
    public ActionResult&lt;IEnumerable&lt;Product&gt;&gt; Get()
        //ActionResult&lt;T&gt; visszatérési érték
/**/{
/**/    return _productService.GetProducts();
/**/}</programlisting>
<simpara>Azonban ez nem fordul, mert interfész típus esetén nem működik a konverzió. Konkrét típust, pl. egy listát kell megadnunk.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/[HttpGet]
/**/public ActionResult&lt;IEnumerable&lt;Product&gt;&gt; Get()
/**/{
        return _productService.GetProducts().ToList(); //ToList bekerült
/**/}</programlisting>
<simpara>Írjuk meg ugyanígy a másik <literal>Get</literal> függvényt is:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/[HttpGet("{id}")]
    public ActionResult&lt;Product&gt; Get(int id)
        //ActionResult&lt;Product&gt; visszatérési érték
/**/{
        return _productService.GetProduct(id);
/**/}</programlisting>
<simpara>Próbáljuk ki mindkét kontroller függvényt (<emphasis>api/products</emphasis>, <emphasis>api/products/1</emphasis>), ellenőrizzük a státuszkódokat is.</simpara>
<simpara>Ami fura, hogy még mindig nem állítottunk explicit státuszkódokat. A logikánk most még nagyon egyszerű, csak a hibamentes ágat kezeltük, így eddig az <literal>ActionResult</literal> alapértelmezései megoldották, hogy <emphasis role="strong">200 (OK)</emphasis>-ot kapjunk.</simpara>
<simpara>Most viszont következzen egy létrehozó művelet:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/[HttpPost]
    public ActionResult&lt;Product&gt; Post([FromBody] Product product)
        //ActionResult&lt;T&gt; visszatérési érték + Product paraméter
/**/{
        var created = _productService.InsertProduct(product);
        return CreatedAtAction(nameof(Get), new { id = created.Id }, created);
/**/}</programlisting>
<simpara>Itt már látszik az <literal>ActionResult</literal> haszna. A konvenciónak megfelelően 201-es kódot akarunk visszaadni. Ehhez a <literal>ControllerBase</literal> ősosztály biztosít segédfüggvényt. A segédfüggvény olyan <literal>ActionResult</literal> leszármazottat ad vissza, ami 201-es kódot szolgáltat a kliensnek. Másik konvenció, hogy a <emphasis>Location</emphasis> HTTP fejlécben legyen egy URL az új termék lekérdező műveletének meghívásához. Ezt az URL-t rakjuk össze a <literal>CreatedAtAction</literal> paraméterei révén.</simpara>
<simpara>Gyakori, hogy a lefele irányú kommunikáció során (kliens felé) bővebb adathalmaz kerül leküldésre, mint amit egy létrehozáskor vagy módosításkor várunk. Esetünkben is az <literal>Orders</literal> és a <literal>Category</literal> propertyk létrehozáskor feleslegesek. Erre a célra jobb egy külön DTO-t létrehozni, ami csak a megfelelő adatokat tartalmazza. Most ideiglenesen tegyük nullozhatóvá ezt a két propertyt.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public record Product
{
    /*többi property*/
    public Category? Category { get; init; } //? módosító bekerült
    public List&lt;Order&gt;? Orders { get; init; } //? módosító bekerült
}</programlisting>
<simpara>Próbáljuk ki a műveletet Swagger felületről. Egy <literal>Product</literal>-ot kell felküldenünk. Erre egy példa érték:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "Name" : "Pálinka",
    "UnitPrice" : 4000,
    "ShipmentRegion" : 1,
    "CategoryId" : 1
}</programlisting>
<warning><simpara>Ha Fiddlerből vagy Postmanből tesztelünk, ne felejtsük el a <emphasis>Content-Type</emphasis> fejlécet  <emphasis role="strong">application/json</emphasis>-re állítani! Figyeljük meg a kapott választ. A válaszból másoljuk ki a <emphasis>Location</emphasis> fejlécből az URL-t és hívjuk meg böngészőből.</simpara></warning>
<simpara>Fiddler Classic példa POST hívásra:</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="images/aspnetcorerest-fiddlerpost.png"/>
  </imageobject>
  <textobject><phrase>Fiddler - POST küldése</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>A módosító, törlő műveleteknél a konvenció megengedi, hogy üres törzsű (body) választ adjunk, ilyenkor a válaszkód <emphasis role="strong">204 (No Content)</emphasis>. Ilyesfajta válasz előállításához is van segédfüggvény, illetve elég csak az <literal>ActionResult</literal> típust megadni visszatérési típusnak:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/[HttpPut("{id}")]
    public ActionResult Put(int id, [FromBody] Product product)
         //ActionResult visszatérési érték + Product paraméter
/**/{
        _productService.UpdateProduct(id, product);
        return NoContent();
/**/}

/**/[HttpDelete("{id}")]
public ActionResult Delete(int id)
     //ActionResult visszatérési érték
/**/{
        _productService.DeleteProduct(id);
        return NoContent();
/**/}</programlisting>
<tip><simpara>PUT mellett a módosításhoz használatos a PATCH is. A PUT konvenció szerint teljes, míg a PATCH részleges felülírásnál használatos. PATCH esetén általában valamilyen patch formátumú adatot küld a kliens, pl. <ulink url="https://tools.ietf.org/html/rfc6902">RFC 6902 - JSON Patch</ulink>. A JSON Patch formátumot jelenleg csak a JSON korábbi sorosító (<emphasis>Newtonsoft.Json</emphasis>) <ulink url="https://docs.microsoft.com/en-us/aspnet/core/web-api/jsonpatch">támogatja</ulink>.</simpara></tip>
<tip><simpara>Gyakori, hogy a PUT művelet esetében nem 204 No Content válasszal térünk vissza, hanem 200 OK státuszkóddal és a módosított erőforrással, hogy a kliens a tényleges érvényre jutott értékekkel befrissíthesse a saját adatait.</simpara></tip>
<simpara>Próbáljuk kitörölni az újonnan felvett terméket Swaggerből/Fiddler-ből/Postman-ből (<emphasis>DELETE</emphasis> igés kérés az <literal>api/products/&lt;új id&gt;</literal> címre, üres törzzsel). Sikerülnie kell, mert még nincs rá idegen kulcs hivatkozás.</simpara>
</section>
<section id="_hibakezelés">
<title>Hibakezelés</title>
<simpara>Eddig főleg csak a hibamentes ágakat (happy path) néztük. A REST konvenciók rendelkeznek arról is, hogy bizonyos hibahelyezetekben milyen <ulink url="https://httpstatuses.com">HTTP választ</ulink> illik adni, például ha a kérésben hivatkozott azonosító nem létezik - 404-es hiba a bevett eljárás. Státuszkódok szempontjából a korábban idézett oldal ad segítséget, a válasz törzsében a hibaüzenet szerkezete tekintetében az <ulink url="https://tools.ietf.org/html/rfc7807">RFC 7807</ulink> ad iránymutatást az ún. <emphasis>Problem Details</emphasis> típusú válaszok bevezetésével. Az ASP.NET Core 2.1-es verzió óta támogatja a <emphasis>Problem Details</emphasis> válaszokat, és általában automatikusan ilyen válaszokat küld.</simpara>
<section id="_400_bad_request">
<title>400 Bad Request</title>
<simpara>Kezdjük a kliens által küldött nem helyes adatokkal. Ez a hibakód nem összekeverendő a 415-tel, ahol az adat formátuma nem megfelelő (XML vagy JSON): ezt általában nem kell kézzel lekezeljük, mivel ezt az ASP.NET megteszi helyettünk. 400-zal olyan hibákat szoktunk lekezelni, ahol a küldött adat formátuma megfelelő, de valamilyen saját validációs logikának nem felel meg a kapott objektum, pl.: egységár nem lehet negatív stb.</simpara>
<simpara>Itt használjuk fel a .NET ún. <ulink url="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation#built-in-attributes"><emphasis>Data Annotation</emphasis> attribútumait</ulink>, amiket a DTO-kon érvényesíthetünk, és az ASP.NET Core figyelembe vesz a művelet végrehajtása során. Vegyünk fel a <literal>Product</literal> DTO osztályban néhány megkötést attribútumok formájában.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">    [Required(ErrorMessage = "Product name is required.", AllowEmptyStrings = false)]
/**/public string Name { get; init; } = null!;

    [Range(1, int.MaxValue, ErrorMessage = "Unit price must be higher than 0.")]
/**/public int UnitPrice { get; init; }</programlisting>
<simpara>Próbáljuk ki egy <emphasis role="strong">POST /api/Products</emphasis> művelet meghívásával. Paraméterként kiindulhatunk a felület által adott minta JSON-ból, csak töröljük ki a navigációs property-ket és sértsük meg valamelyik (vagy mindkét) fenti szabályt. Egy példa törzs:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "Name" : "",
    "UnitPrice" : 0,
    "ShipmentRegion" : 1,
    "CategoryId" : 1
}</programlisting>
<simpara>A válasz 400-as kód és valami hasonló, RFC 7807-nek megfelelő törzs lesz:</simpara>
<programlisting language="javascript" linenumbering="unnumbered">{
    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
    "title": "One or more validation errors occurred.",
    "status": 400,
    "traceId": "|2f35d378-4420cbafb80aec04.",
    "errors": {
        "Name": [
            "Product name is required."
        ],
        "UnitPrice": [
            "Unit price must be higher than 0."
        ]
    }
}</programlisting>
</section>
<section id="_404_not_found_kontroller_szinten">
<title>404 Not Found - kontroller szinten</title>
<simpara>Konvenció szerint 404-es hibát kellene adnunk, ha a keresett azonosítóval nem található erőforrás - esetünkben termék. Jelenleg a <literal>ProductService</literal> <literal>EntityNotFoundException</literal>-t dob, és amennyiben Development módban futtatjuk az alkalmazást, a cifra hibaoldal jelenik meg, amit a <emphasis>DeveloperExceptionPage</emphasis> middleware generál. Ha kivesszük a middleware-t (vagy nem Development módban indítjuk, de ekkor gondoskodnunk kell connection string-ről, ami eddig csak a Development konfigurációban volt beállítva), akkor 500-as hibát kapunk vissza.</simpara>
<warning><simpara>A kezeletlen kivételek általában 500-as hibakód formájában kerülnek vissza a kliensre, mindenfajta egyéb információ nélkül (üres oldalként jelenik meg). Ez a jobbik eset, ahhoz képest, ha a teljes kivételszöveg és stack trace is visszakerülne. Az átlagos felhasználók nem tudják értelmezni, viszont a támadó szándékúaknak értékes információt jelenthet, így ajánlott elkerülni, hogy a kivétel ilyen módon kijusson. Ez az elkerülés az úgynevezett <emphasis>exception shielding</emphasis> technika, és az ASP.NET Core alapértelmezetten alkalmazza.</simpara></warning>
<simpara>Legegyszerűbb módszer a kontroller műveletben érvényesíteni a konvenciót:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/[HttpGet("{id}")]
/**/public ActionResult&lt;Product&gt; Get(int id)
/**/{
        try
        {
/**/        return _productService.GetProduct(id);
        }
        catch (EntityNotFoundException)
        {
            return NotFound();
        }
/**/}</programlisting>
<tip><simpara>Alternatív megoldás, hogy a <literal>ProductService</literal> egy <literal>null</literal> értékkel jelezné, hogy nincs találat. Ezesetben a fenti kódban a <literal>null</literal> értékre kellene vizsgálni, pl. <literal>if</literal> szerkezettel.</simpara></tip>
<simpara>Próbáljuk ki, hogy 404-es státuszkódot és annak megfelelő <emphasis>problem details</emphasis>-t kapunk-e, ha egy nem létező termékazonosítóval hívjuk a fenti műveletet.</simpara>
<simpara>Ha saját <emphasis>problem details</emphasis>-t szeretnénk a 404-es kód mellé, akkor kézzel összerakhatjuk és visszaküldhetjük.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/catch (EntityNotFoundException)
/**/{
        ProblemDetails details= new ProblemDetails
        {
            Title = "Invalid ID",
            Status = StatusCodes.Status404NotFound,
            Detail = $"No product with ID {id}"
        };
        return NotFound(details); //ProblemDetails átadása
/**/}</programlisting>
<simpara>Így is próbáljuk ki. Az általunk megadott üzenetet kell visszakapjuk.</simpara>
</section>
<section id="_404_not_found_globális_kivételleképezéssel">
<title>404 Not Found - globális kivételleképezéssel</title>
<simpara>A rendhagyó válaszok előállításánál előnyös lehet, ha az alacsonyabb rétegekből specifikus kivételeket dobunk, mert ezeket egy központi helyen szisztematikusan átalakíthatjuk konvenciónak megfelelő HTTP válaszokká. Ez a képesség egyelőre még nem érhető el beépítetten, ezért egy <ulink url="https://github.com/khellang/Middleware">közösségi fejlesztésű NuGet csomagot</ulink> használunk fel.</simpara>
<simpara>Telepítsük fel a <emphasis>Hellang.Middleware.ProblemDetails</emphasis> csomagot az API projektbe. Megtehetjük a szokásos módon, de akár a <emphasis>Package Manager Console</emphasis>-ból is a következő paranccsal (az API projekt legyen megadva, mint <emphasis>Default Project</emphasis>):</simpara>
<programlisting language="powershell" linenumbering="unnumbered">Install-Package Hellang.Middleware.ProblemDetails</programlisting>
<simpara>Szokás szerint konfiguráljuk a legfelső szintű kódban. Sose adjuk vissza a kivétel részleteit (szigorú <emphasis>exception shielding</emphasis>), illetve a saját kivételtípusunkat képezzük le 404-es hibára.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">builder.Services.AddProblemDetails(options =&gt;
{
    options.IncludeExceptionDetails = (ctx,ex) =&gt; false;
    options.MapToStatusCode&lt;EntityNotFoundException&gt;(StatusCodes.Status404NotFound);
});</programlisting>
<simpara>Illesszük a pipeline-ba a legelső helyre:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/var app = builder.Build();
    app.UseProblemDetails();</programlisting>
<simpara>Térjünk vissza a korábbi, nem kivétel-elkapós változatra, az előzőt kommentezzük ki:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">[HttpGet("{id}")]
public ActionResult&lt;Product&gt; Get(int id)
{
    return _productService.GetProduct(id);
}</programlisting>
<simpara>Próbáljuk ki: hasonlóan kell működjön, mint a kontroller szintű változat, de ez általánosabb, bármely műveletből <literal>EntityNotFoundException</literal> érkezik, azt kezeli, nem kell minden műveletben megírni a kezelő logikát.</simpara>
</section>
<section id="_500_internal_server_error">
<title>500 Internal Server Error</title>
<simpara>Próbáljunk kitörölni egy nem létező terméket <emphasis role="strong">DELETE api/products/&lt;nem létező id&gt;</emphasis> kéréssel. Az újonnan beállított MW a nem kezelt kivétel esetén is egy alapszintű Problem Details választ állít elő 500-as kóddal.</simpara>
</section>
<section id="_azonosítók_ellenőrzése">
<title>Azonosítók ellenőrzése</title>
<simpara>Készítsük fel a módosító és törlő műveleteket is a nem létező azonosítók konvenció szerinti kezelésére.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/public void UpdateProduct(int productId, Product updatedProduct)
/**/{
/**/    /*...*/
        try
        {
/**/         _context.SaveChanges();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!_context.Products.Any(p =&gt; p.Id == productId))
                throw new EntityNotFoundException("Nem található a termék");
            else
                throw;
        }
/**/}

/**/public void DeleteProduct(int productId)
/**/{
/**/    /*...*/
        try
        {
/**/        _context.SaveChanges();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!_context.Products.Any(p =&gt; p.Id == productId))
                throw new EntityNotFoundException("Nem található a termék");
            else
                throw;
        }
/**/}</programlisting>
<simpara>Ez egy optimista megközelítés: feltételezzük, hogy helyes azonosítót kapunk. Ha kivételes esetben mégsem, akkor az UPDATE/DELETE utasítás nem a megfelelő számú sort módosítja és <literal>DbUpdateConcurrencyException</literal>-t kapunk. Ekkor vizsgáljuk csak meg, hogy az azonosító helyes-e.</simpara>
<tip><simpara>Egy másik megközelítés szerint a DELETE műveletnek idempotensnek kellene lennie, tehát egymás után többször végrehajtva is sikeres eredményt kell kapjunk. Ez azt is jelenti, hogy 404-es hiba helyet 204 No Content státuszkódot kell küldenünk akkor is, ha nem található adott ID-val entitás. Ezt a jelenlegi kódban egyszerűen implementálhatjuk, hogy nem dobunk kivételt a megfelelő ágban.</simpara></tip>
</section>
<section id="_saját_hibaüzenet">
<title>Saját hibaüzenet</title>
<simpara>Módosítsuk a hibakezelő MW konfigurációját a legfelső szintű kódban, hogy a kivétel szövege bekerüljön a válaszba. Ez akkor lehet hasznos, ha a felhasználónak kiírandó hibaüzenetet is vissza akarjuk küldeni (másik lehetőség, hogy a kliens állítja elő, pl. a státuszkód alapján).</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/builder.Services.AddProblemDetails(options =&gt;
/**/{
/**/    options.IncludeExceptionDetails = (ctx, ex) =&gt; false;
        options.Map&lt;EntityNotFoundException&gt;(
            (ctx, ex) =&gt;
            {
                var pd=StatusCodeProblemDetails.Create(StatusCodes.Status404NotFound);
                pd.Title = ex.Message;
                return pd;
            }
        );
/**/});</programlisting>
<warning><simpara>Az <emphasis>exception shielding</emphasis> elv miatt csak olyan kivételeknél alkalmazzuk, ahol a felhasználók számára hasznos, de nem technikai jellegű információt tartalmaz a kivétel szövege.</simpara></warning>
<simpara>Próbáljuk ki, hogy az egy termék lekérdezésénél, a módosításnál és a törlésnél is a rossz azonosító egységesen működik-e: 404-es hibát ad vissza, a Problem Details-ben a kivétel szövegével.</simpara>
</section>
</section>
<section id="_aszinkron_műveletek">
<title>Aszinkron műveletek</title>
<simpara>Aszinkron műveletek alkalmazásával hatékonyságjavulást érhetünk el: nem feltétlenül az egyes műveleteink lesznek gyorsabbak, hanem időegység alatt több műveletet tudunk kiszolgálni. Ennek oka, hogy az <literal>await</literal>-nél (például egy adatbázis művelet elküldésekor) a várakozási idejére történő kiugrásnál, ha vissza tudunk ugrálni egészen az ASP.NET engine szintjéig, akkor a végrehajtó környezet a kiszolgáló szálat a várakozás idejére más kérés kiszolgálására felhasználhatja.</simpara>
<tip><simpara>Ökölszabály, hogy ha elköteleztük magunkat az aszinkronitás mellett, akkor ha megoldható, az aszinkronitást vezessük végig a kontrollertől az adatbázis művelet végrehajtásáig minden rétegben. Ha egy API-nak van <emphasis>TAP</emphasis> jellegű változata, akkor azt részesítsük előnyben (pl. <literal>SaveChanges</literal> helyett <literal>SaveChangesAsync</literal>). Ha aszinkronból szinkronba váltunk, csökkentjük a hatékonyságot, rosszabb esetben deadlock-ot is <ulink url="https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html">előidézhetünk</ulink>.</simpara></tip>
<simpara>Vezessük végig az aszinkronitást egy művelet teljes végrehajtásán:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Service réteg - interfész

/**/public interface IProductService
/**/{
        //public void UpdateProduct(int productId, Product updatedProduct);
        public Task UpdateProductAsync(int productId, Product updatedProduct);
/**/    //többi fv.
/**/}

// Service réteg - implementáció

    public async Task UpdateProductAsync(int productId, Product updatedProduct)
/**/{
/**/    var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(updatedProduct);
/**/    efProduct.Id = productId;
/**/    _context.Attach(efProduct).State = EntityState.Modified;
/**/
/**/    try
/**/    {
            await _context.SaveChangesAsync(); //async változat hívása
/**/    }
/**/    catch (DbUpdateConcurrencyException)
/**/    {
/**/          if (!await _context.Products
                        .AnyAsync(p =&gt; p.Id == productId))
            //async változat hívása
/**/               throw new EntityNotFoundException("Nem található a termék");
/**/        else
/**/            throw;
/**/    }
/**/}

// Kontroller réteg

    public async Task&lt;ActionResult&gt; Put(int id, [FromBody] Product product)
/**/{
/**/  await _productService.
                .UpdateProductAsync(id, product);
                //async változat hívása
/**/  return NoContent();
/**/}</programlisting>
<warning><simpara>Az <emphasis>Async</emphasis> végződés alkalmazása kontroller műveletek nevében jelenleg nem ajánlott, mert könnyen <ulink url="https://github.com/dotnet/aspnetcore/issues/8998">hibákba futhatunk</ulink>.</simpara></warning>
<simpara>Próbáljuk ki, például küldjünk PUT-ot az <literal>api/products/1</literal> címre, állítsuk be a <emphasis>Content-Type: application/json</emphasis> fejlécet és a POST-nál használt JSON-t küldjük a törzsben. Ezzel az 1-es <literal>id</literal>-jű termék adatait fogjuk felülírni.</simpara>
</section>
<section id="_végállapot">
<title>Végállapot</title>
<simpara>A többi műveletet aszinkronizálva az alábbi a végállapot (elérhető a kapcsolódó GitHub repo <ulink url="https://github.com/bmeaut/WebApiLab/tree/net6">net6-os ágán</ulink> is):</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public interface IProductService
{
    public Task&lt;Product&gt; GetProductAsync(int productId);
    public Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductsAsync();
    public Task&lt;Product&gt; InsertProductAsync(Product newProduct);
    public Task UpdateProductAsync(int productId, Product updatedProduct);
    public Task DeleteProductAsync(int productId);
}

public class ProductService : IProductService
{
    private readonly AppDbContext _context;
    private readonly IMapper _mapper;

    public ProductService(AppDbContext context, IMapper mapper)
    {
        _context = context;
        _mapper = mapper;
    }

    public async Task&lt;Product&gt; GetProductAsync(int productId)
    {
        return await _context.Products
            .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)
            .SingleOrDefaultAsync(p =&gt; p.Id == productId)
            ?? throw new EntityNotFoundException("Nem található a termék");
    }

    public async Task&lt;IEnumerable&lt;Product&gt;&gt; GetProductsAsync()
    {
        var products = await _context.Products
            .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)
            .ToListAsync();

        return products;
    }

    public async Task&lt;Product&gt; InsertProductAsync(Product newProduct)
    {
        var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(newProduct);
        _context.Products.Add(efProduct);
        await _context.SaveChangesAsync();
        return await GetProductAsync(efProduct.Id);
    }

    public async Task UpdateProductAsync(int productId, Product updatedProduct)
    {
        var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(updatedProduct);
        efProduct.Id = productId;
        var entry = _context.Attach(efProduct);
        entry.State = EntityState.Modified;
        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await _context.Products.AnyAsync(p =&gt; p.Id == productId))
                throw new EntityNotFoundException("Nem található a termék");
            else
                throw;
        }
    }

    public async Task DeleteProductAsync(int productId)
    {
        _context.Products.Remove(
            new Dal.Entities.Product(null!) { Id = productId });
        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!await _context.Products.AnyAsync(p =&gt; p.Id == productId))
                throw new EntityNotFoundException("Nem található a termék");
            else
                throw;
        }
    }
}

[Route("api/[controller]")]
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;

    public ProductsController(IProductService productService)
    {
        _productService = productService;
    }

    // GET: api/&lt;ProductsController&gt;
    [HttpGet]
    public async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; Get()
    {
        return (await _productService.GetProductsAsync()).ToList();
    }

    // GET api/&lt;ProductsController&gt;/5
    [HttpGet("{id}")]
    public async Task&lt;ActionResult&lt;Product&gt;&gt; Get(int id)
    {
        return await _productService.GetProductAsync(id);
    }

    // POST api/&lt;ProductsController&gt;
    [HttpPost]
    public async Task&lt;ActionResult&lt;Product&gt;&gt; Post([FromBody] Product product)
    {
        var created = await _productService.InsertProductAsync(product);
        return CreatedAtAction(nameof(Get), new { id = created.Id }, created);
    }

    // PUT api/&lt;ProductsController&gt;/5
    [HttpPut("{id}")]
    public async Task&lt;ActionResult&gt; Put(int id, [FromBody] Product value)
    {
        await _productService.UpdateProductAsync(id, value);
        return NoContent();
    }

    // DELETE api/&lt;ProductsController&gt;/5
    [HttpDelete("{id}")]
    public async Task&lt;ActionResult&gt; Delete(int id)
    {
        await _productService.DeleteProductAsync(id);
        return NoContent();
    }
}</programlisting>
</section>
</article>
