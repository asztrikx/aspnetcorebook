<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>Automatizált tesztelés</title>
</articleinfo>
<section id="_segédeszközök">
<title>Segédeszközök</title>
<itemizedlist>
<listitem>
<simpara>
kapcsolódó GitHub repo: <ulink url="https://github.com/bmeaut/WebApiLab">https://github.com/bmeaut/WebApiLab</ulink>
</simpara>
<itemizedlist>
<listitem>
<simpara>
elég csak <ulink url="https://github.com/bmeaut/WebApiLab/archive/refs/heads/net6-test-init.zip">zip-ként letölteni</ulink> a <literal>net6-test-init</literal> ágat, nem kell klónozni
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section id="_bevezetés">
<title>Bevezetés</title>
<simpara>Az automatizált tesztelés az alkalmazásfejlesztés egyik fontos lépése, mivel ezzel tudunk meggyőződni arról, hogy egy-egy funkció akkor is helyesen működik, ha az alkalmazás egy másik részén valamit módosítunk. Hogy ezt az ellenőrzést ne kelljen minden egyes alkalommal manuálisan végrehajtani az alkalmazáson, programozott teszteket szoktunk írni, amelyek futtatását CI/CD folyamatokban automatizálhatjuk.</simpara>
<simpara>A tesztek több típusát ismerhetjük:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">Unit test (egységteszt)</emphasis> célja, hogy egy adott osztály egy metódusának a viselkedését önmagába vizsgáljuk úgy, hogy a függőségeit <ulink url="https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices#lets-speak-the-same-language">mock/fake objektumokkal</ulink> helyettesítjük, hogy azok a tesztesetnek megfelelően viselkedjenek vagy megfigyelhetőek legyenek.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">Integrációs teszt / End-2-end teszt / funkcionális teszt</emphasis> esetében a célunk, hogy a teljes rendszert meghajtsuk úgy, hogy az integrációk (SQL kapcsolat, egyéb szolgáltatások) is tesztelésre kerülnek, illetve a BE szempontjából vizsgáljuk azt is, hogy a rendszer interfésze helyesen válaszol-e a különböző kérésekre.
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">UI teszt</emphasis> esetében azt vizsgáljuk, hogy a felhasználói felület a különböző felhasználói interakciókra, eseményekre helyesen rajzolja-e ki az elvárt felületeket.
</simpara>
</listitem>
</itemizedlist>
<simpara>A fenti tesztelési módok mindegyike fontos, de érdemes egy olyan egészséges egyensúlyt megtalálni, ahol a lehető legjobban lefedhetőek a legfontosabb funkcionalitások különböző tesztesetekkel.</simpara>
</section>
<section id="_automatizált_tesztelés_net_környezetben">
<title>Automatizált tesztelés .NET környezetben</title>
<simpara>Automatizált tesztelésre több keretrendszer is használható .NET környezetben, de ASP.NET Core alkalmazások esetében a legelterjedtebb ilyen könyvtár az <ulink url="https://xunit.net/"><emphasis role="strong">xUnit</emphasis></ulink>. Ebben a keretrendszerben lehetőségünk van tesztesetek definiálására, akár a bemenetek variálásával is, illetve kellően rugalmas, ahhoz, hogy a tesztek feldolgozási mechanizmusa kiterjeszthető legyen.</simpara>
<simpara>Unit tesztek esetében az osztályok függőségeit le kell cseréljük, amire több library is lehetőséget nyújt. A legelterjedtebbek a <ulink url="https://github.com/moq"><emphasis role="strong">Moq</emphasis></ulink> és az <ulink url="https://nsubstitute.github.io/"><emphasis role="strong">NSubstitute</emphasis></ulink>.</simpara>
<simpara>Gyakran szükséges funkció, hogy a bemenő adatok előállítása során szeretnénk a valóságra hasonlító véletlenszerű/generált példaadatokat megadni. Ehhez egy bevált osztálykönyvtár a <ulink url="https://github.com/bchavez/Bogus"><emphasis role="strong">Bogus</emphasis></ulink>.</simpara>
<simpara>A tesztesetek elvárt eredményének a vizsgálatát asszertálásnak nevezzük (<emphasis>assert</emphasis>), aminek az írásához nagy segítséget tud nyújtani a <ulink url="https://fluentassertions.com"><emphasis role="strong">Fluent Assertions</emphasis></ulink> könyvtár. Ez nem csak a szintaktikát teszi olvashatóbbá fluent szintakszissal, hanem több olyan beépített segédlogikát tartalmaz, amivel tömörebbé tehető az <emphasis>assert</emphasis> logika (pl.: objektumok mélységi összehasonlítása érték szerint).</simpara>
</section>
<section id="_integrációs_tesztelés">
<title>Integrációs tesztelés</title>
<simpara>Ezen gyakorlat keretében csak integrációs teszteket fogunk készíteni.</simpara>
<section id="_teszt_projekt">
<title>Teszt projekt</title>
<simpara>Vegyünk fel a solutionbe egy új xUnit (.NET 6) típusú projektet <emphasis>WebApiLab.Tests</emphasis> néven. A létrejövő tesztosztályt és fájlját nevezzük át <emphasis>ProductControllerTests</emphasis> névre. Ide fogjuk a ``ProductController``hez kapcsolódó műveletekre vonatkozó integrációs teszteket készíteni.</simpara>
<simpara>Vegyük fel az alábbi NuGet csomagokat a teszt projektbe. A <emphasis>Bogus</emphasis>ról és a <emphasis>Fluent Assertions</emphasis>ről már volt szó. A <emphasis>Microsoft.AspNetCore.Mvc.Testing</emphasis> csomag olyan segédszolgáltatásokat nyújt, amivel integrációs tesztekhez egy in-process teszt szervert tudunk futtatni, és ennek a meghívásában is segítséget nyújt. A projektfájlban a többi <literal>PackageReference</literal> mellé (menu:a projekten jobbklikk[Edit Project File]):</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;PackageReference Include="Bogus" Version="34.0.2" /&gt;
&lt;PackageReference Include="FluentAssertions" Version="6.6.0" /&gt;
&lt;PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="6.0.4" /&gt;</programlisting>
<simpara>Vegyük fel az <emphasis role="strong">Api</emphasis> projektet projekt referenciaként a teszt projektbe. A projektfájlban egy másik <literal>ItemGroup</literal> mellé:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;ItemGroup&gt;
  &lt;ProjectReference Include="..\WebApiLab.Api\WebApiLab.Api.csproj" /&gt;
&lt;/ItemGroup&gt;</programlisting>
</section>
<section id="_teszt_szerver">
<title>Teszt szerver</title>
<simpara>A tesztszervernek meg kell tudnunk mondani, hogy melyik osztály adja az alkalmazásunk belépési pontját. Viszont mivel top level statement szintaktikájú a <literal>Program</literal> osztályunk, annak láthatósága internal, ami a tesztelés szempontjából nem szerencsés (a hasonló esetekben alkalmazott <literal>InternalsVisibleTo</literal> sem lenne <ulink url="https://stackoverflow.com/a/69483450/1406798">ebben az esetben megoldás</ulink>). Helyette tegyük a <literal>Program</literal> osztályt publikussá egy <literal>partial</literal> deklarációval. Vegyük fel az alábbi partial kiegészítést az API projektben a legfelső szintű kód végére:</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public partial class Program { }</programlisting>
<simpara>Az integrációs tesztünkhöz az in-process teszt szervert egy <literal>WebApplicationFactory&lt;TEntryPoint&gt;</literal> leszármazott osztály fogja létrehozni. Ez a segéd ősosztály a fenti Microsoft.AspNetCore.Mvc.Testing csomagból jön. Itt lehetőségünk van a teszt szerverünket konfigurálni, így akár a DI konfigurációt is.</simpara>
<simpara>Hozzunk létre egy osztályt a teszt projektbe <literal>CustomWebApplicationFactory</literal> néven, ami származzon a <literal>WebApplicationFactory&lt;Program&gt;</literal> osztályból és definiáljuk felül a <literal>CreateHost</literal> metódusát.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public class CustomWebApplicationFactory : WebApplicationFactory&lt;Program&gt;
{
    protected override IHost CreateHost(IHostBuilder builder)
    {
        builder.UseEnvironment("Development");
        builder.ConfigureServices(services =&gt;
        {
            services.AddScoped(sp =&gt; new DbContextOptionsBuilder&lt;AppDbContext&gt;()
                    .UseSqlServer(@"connection string")
                    .UseApplicationServiceProvider(sp)
                    .Options);
        });

        var host = base.CreateHost(builder);

        using var scope = host.Services.CreateScope();
        scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;()
            .Database.EnsureCreated();

        return host;
    }
}</programlisting>
<simpara>Megfigyelhetjük, hogy itt is LocalDB-t használunk (mivel integrációs teszt), de a connection stringet lecseréjük a DI konfigurációban. A connection string alapvetően egyezhet a tesztelendő projektben használttal, csak az adatbázisnevet változtassuk meg. Az adatbázis automatikusan létrejön és a migrációk is lefutnak az <literal>EnsureCreated</literal> meghívásával - az első lefutáskor.</simpara>
<tip><simpara>Mivel az <literal>AppDbContext</literal> Scoped életciklussal van regisztrálva a DI-ba, szükséges létrehozni egy scope-ot, hogy el tudjuk kérni a DI konténertől. Ezt természetesen ha HTTP kérés közben lennénk az ASP.NET Core automatikusan megtenné.</simpara></tip>
</section>
<section id="_kontrollertesztek_előkészítése">
<title>Kontrollertesztek előkészítése</title>
<simpara>Alakítsuk át a <literal>ProductControllerTests</literal> osztályt. Az osztály valósítsa meg az <literal>IClassFixture&lt;CustomWebApplicationFactory&gt;</literal> interfészt, amivel azt tudjuk jelezni az xUnit-nak, hogy kezelje a <literal>CustomWebApplicationFactory</literal> életciklusát (tesztek között <ulink url="https://xunit.net/docs/shared-context#class-fixture">megosztott objektum</ulink> lesz), illetve pluszban lehetőségünk van ezt a tesztosztályokban konstruktoron keresztül elkérni.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public partial class ProductControllerTests : IClassFixture&lt;CustomWebApplicationFactory&gt;
{
    private readonly WebApplicationFactory&lt;Program&gt; _appFactory;

    public ProductControllerTests(CustomWebApplicationFactory appFactory)
    {
        _appFactory = appFactory;
    }
}</programlisting>
<warning><simpara>Az xUnit nem tartalmaz DI konténert. Csak azok a konstruktorparaméterek töltődnek ki, amelyek a dokumentációban megtalálhatók. A <literal>CustomWebApplicationFactory</literal> típusú paraméter azért töltődik ki, mert az osztály az interfészében jelzi, hogy megosztott kontextusként <literal>CustomWebApplicationFactory</literal>-t vár.</simpara></warning>
<simpara>Hozzunk létre a Bogus könyvtárral egy olyan <literal>Faker&lt;Product&gt;</literal> objektumot, amivel az API-nak küldendő DTO objektum generálását végezzük el. Azonosítóként küldjünk 0 értéket, mivel a létrehozás műveletet fogjuk tesztelni, kategória esetében pedig az 1-et, mivel a migráció által létrehozott 1-es kategóriát fogjuk tudni csak használni. A többi esetben használjuk a Bogus beépített lehetőségeit a név és a szám értékek random generálásához.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// ...
    private readonly Faker&lt;Product&gt; _dtoFaker;

/**/public ProductControllerTests(CustomWebApplicationFactory appFactory)
/**/{
        // ...
        _dtoFaker = new Faker&lt;Product&gt;()
            .RuleFor(p =&gt; p.Id, 0)
            .RuleFor(p =&gt; p.Name, f =&gt; f.Commerce.Product())
            .RuleFor(p =&gt; p.UnitPrice, f =&gt; f.Random.Int(200, 20000))
            .RuleFor(p =&gt; p.ShipmentRegion,
                     f =&gt; f.PickRandom&lt;Dal.Entities.ShipmentRegion&gt;())
            .RuleFor(p =&gt; p.CategoryId, 1)
            .RuleFor(p =&gt; p.RowVersion, f =&gt; f.Random.Bytes(5));
/**/}</programlisting>
<simpara>A kliensoldali JSON sorosítást a szerveroldallal kompatibilisen kell megtegyük. Ehhez készítsünk egy <literal>JsonSerializerOptions</literal> objektumot, amibe beállítjuk, hogy a felsorolt típusokat szöveges értékként kezelje. Mivel ugyanazt a példányt akarjuk használni a tesztekben, ezért a példányt a <literal>CustomWebApplicationFactory</literal> (mint tesztek közötti megosztott objektum) készítse el és ajánlja ki.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">public JsonSerializerOptions SerializerOptions { get; }

public CustomWebApplicationFactory()
{
    JsonSerializerOptions jso = new(JsonSerializerDefaults.Web);
    jso.Converters.Add(new JsonStringEnumConverter());
    SerializerOptions= jso;
}</programlisting>
<simpara>A <literal>ProductControllerTests</literal> a kiajánlott <literal>JsonSerializerOptions</literal>-t vegye át.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// ...
private readonly JsonSerializerOptions _serializerOptions;

public ProductControllerTests(CustomWebApplicationFactory appFactory)
{
    // ...
    _serializerOptions = appFactory.SerializerOptions;
}</programlisting>
<warning><simpara>Sajnos ezt a <literal>JsonSerializerOptions</literal> példányt minden sorosítást igénylő műveletnél majd át kell adnunk, mivel az alapértelmezett JSON sorosítónak <ulink url="https://github.com/dotnet/runtime/issues/31094">nincs publikusan elérhető API-ja</ulink> alapértelmezett sorosítási beállítások megadásához. Ugyanakkor fontos, hogy kerüljük a <literal>JsonSerializerOptions</literal> <ulink url="https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/configure-options?pivots=dotnet-6-0#reuse-jsonserializeroptions-instances">felesleges példányosítását</ulink>. Ugyanolyan beállításokat igénylő műveletek lehetőleg ugyanazt a példányt használják. Ezt most az XUnit megosztott kontextusával oldottuk meg.</simpara></warning>
</section>
<section id="_post_művelet_alapműködés_tesztelése">
<title>POST művelet alapműködés tesztelése</title>
<simpara>Készítsük el az első tesztünket a <literal>ProductController</literal> <literal>Post</literal> műveletéhez. Érdemes azt az osztálystruktúrát követni, hogy minden művelethez / függvényhez külön teszt osztályokat hozunk létre, ami akár több tesztesetet is tartalmazhat. Ez a teszt osztályt beágyazott osztályként (<literal>Post</literal>) hozzuk létre egy külön partial fájlban (<emphasis role="strong">ProductIntegrationTests.Post.cs</emphasis>) a nagyobb egységhez tartozó tesztosztályon belül. Ezzel szépen strukturáltan tudjuk tartani a <emphasis role="strong">Test Explorerben</emphasis> (lásd később) is a teszteseteinket. Pluszban még származtassuk le a tartalmazó osztályból, hogy a tesztesetek elérhessék a fentebb létrehozott osztályváltozókat.</simpara>
<tip><simpara>Érdekesség, hogy nem kell <literal>protected</literal> láthatóságúaknak lenniük a fenti osztályváltozóknak, ha beágyazott osztály akarja elérni azokat.</simpara></tip>
<programlisting language="csharp" linenumbering="unnumbered">/**/public partial class ProductControllerTests
/**/{
        //...
        public class Post : ProductControllerTests
        {
            public Post(CustomWebApplicationFactory appFactory)
                : base(appFactory)
            {
            }
        }
/**/}</programlisting>
<simpara>A tesztesetek a teszt osztályban metódusok fogják reprezentálni, amelyek <literal>[Fact]</literal> vagy <literal>[Theory]</literal> attribútummal rendelkeznek. A fő különbég az, hogy a <literal>Fact</literal> egy statikus tesztesetet reprezentál, míg a <literal>Theory</literal> bemenő paraméterekkel rendelkezhet.</simpara>
<simpara>Elsőként az egyenes ágat teszteljük le, hogy a beszúrás helyesen lefut-e, és a megfelelő HTTP válaszkódot, a <emphasis>location</emphasis> HTTP fejlécet, és válasz DTO-t adja-e vissza. Hozzunk létre egy függvényt <literal>Fact</literal> attribútummal <literal>Should_Succeded_With_Created</literal> néven.</simpara>
<simpara>A teszteset az <ulink url="https://learn.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2022#write-your-tests">AAA (Arrange, Act, Assert)</ulink> mintát követi, ahol 3 részre tagoljuk magát a tesztesetet. Az <emphasis>Arrange</emphasis> fázisban előkészítjük a teszteset körülményeit. Az <emphasis>Act</emphasis> fázisban elvégezzük a tesztelendő műveletet. Az <emphasis>Assert</emphasis> fázisban pedig megvizsgáljuk a végrehajtott művelet eredményeit, mellékhatásait.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">[Fact]
public async Task Should_Succeded_With_Created()
{
    // Arrange

    // Act

    // Assert
}</programlisting>
<simpara>Az <emphasis>Arrage</emphasis>-ben kérjünk el egy a teszt szerverhez kapcsolódó <literal>HttpClient</literal> objektumot, illetve hozzunk létre egy felküldendő DTO-t.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Arrange
var client = _appFactory.CreateClient();
var dto = _dtoFaker.Generate();</programlisting>
<simpara>Az <emphasis>Act</emphasis> fázisban küldjünk el egy POST kérést a megfelelő végpontra a megfelelő sorosítási beállításokkal és olvassuk ki a választ.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Act
var response = await client.PostAsJsonAsync("/api/products", dto, _serializerOptions);
var p = await response.Content.ReadFromJsonAsync&lt;Product&gt;(_serializerOptions);</programlisting>
<simpara>Az <emphasis>Assert</emphasis> fázisban pedig fogalmazzuk meg a FluentValidation könyvtár segítségével az elvárt eredmény szabályait. Gondoljunk arra is, hogy a <literal>Category</literal>, <literal>Order</literal>, <literal>Id</literal> és <literal>RowVersion</literal> property-k esetében nem az az elvárt válasz, amit felküldünk a szerverre, ezért ezeket szűrjük le az összehasonlításból és vizsgáljuk őket külön szabállyal.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Assert
response.StatusCode.Should().Be(HttpStatusCode.Created);
response.Headers.Location
    .Should().Be(
        new Uri(_appFactory.Server.BaseAddress, $"/api/Products/{p.Id}")
    );

p.Should().BeEquivalentTo(
    dto,
    opt =&gt; opt.Excluding(x =&gt; x.Category)
        .Excluding(x =&gt; x.Orders)
        .Excluding(x =&gt; x.Id)
        .Excluding(x =&gt; x.RowVersion));
p.Category.Should().NotBeNull();
p.Category.Id.Should().Be(dto.CategoryId);
p.Orders.Should().BeEmpty();
p.Id.Should().BeGreaterThan(0);
p.RowVersion.Should().NotBeEmpty();</programlisting>
<warning><simpara>A Fluent Assertions <ulink url="https://github.com/fluentassertions/fluentassertions/issues/1115">jelenleg még nem működik együtt</ulink> a nem nullozható referencia típusokkal kapcsolatos ellenőrzési logikákkal, így az <emphasis>Assert</emphasis> részen kaphatunk ennek kapcsán figyelmeztetéseket <literal>Should().NotBeNull()</literal> hívások után is.</simpara></warning>
<simpara>A POST művelet megváltoztatná az adatbázis állapotát, amit célszerű lenne elkerülni. Ezt legegyszerűbben úgy érhetjük el, hogy nyitunk egy tranzakciót a tesztben, amit nem commitolunk a teszt lefutása során. Ehhez vegyük fel az alábbi utasításokat az <emphasis>Arrange</emphasis> fázisban.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">    // Arrange
    _appFactory.Server.PreserveExecutionContext = true;
    using var tran = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);

/**/var client = _appFactory.CreateClient();
/**/var dto = _dtoFaker.Generate();</programlisting>
<simpara>Tranzakciót a .NET <literal>TransactionScope</literal> osztállyal fogunk most nyitni, amin engedélyezzük az aszinkron támogatást is. Ahhoz pedig, hogy a tesztben létrehozott tranzakció érvényre jusson a teszt szerveren is, a <literal>PreserveExecutionContext</literal> tulajdonságot be kell kapcsoljuk.</simpara>
<simpara>Próbáljuk ki a menu:Test[Run All Test] menüpont segítségével. A <ulink url="https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2022#run-tests-in-test-explorer">Test Explorerben</ulink> figyeljük meg az eredményt.</simpara>
</section>
<section id="_post_művelet_hibaág_tesztelése">
<title>POST művelet hibaág tesztelése</title>
<simpara>Készítsünk egy tesztesetet, ami a hibás terméknév ágat teszteli le. Mivel ez két esetet is magában foglal (null, üres string), használjunk paraméterezhető tesztesetet, tehát <literal>Theory</literal>-t. A teszteset bemenő paramétereit többféleképpen is meg lehet adni. Mi most válasszuk az <literal>InlineData</literal> megközelítést, ahol attribútumokkal a teszteset fölött közvetlenül megadhatóak a bemenő paraméter értékei. Ilyen esetben az attribútumban megadott értékeket a teszt metódus paraméterlistáján kell elkérjük. Esetünkben a név hibás értékeit várjuk első paraméterként, második paraméterként pedig az elvárt hibaüzenetet.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">[Theory]
[InlineData("", "Product name is required.")]
[InlineData(null, "Product name is required.")]
public async Task Should_Fail_When_Name_Is_Invalid(string name, string expectedError)
{
    // Arrange

    // Act

    // Assert
}</programlisting>
<simpara>Az előző tesztesethez hasonlóan hozzunk létre a teszt szervert és a DTO-t, de most a nevet a paraméter alapján töltsük fel. Bár elvileg nem lenne szükséges tranzakciókezelés, hiszen nem szabadna adatbázis módosításnak történnie, a biztonság kedvéért implementáljuk itt is a tranzakciókezelést.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Arrange
 _appFactory.Server.PreserveExecutionContext = true;
using var tran = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);
var client = _appFactory.CreateClient();
var dto = _dtoFaker.RuleFor(x =&gt; x.Name, name).Generate();</programlisting>
<simpara>Az <emphasis>Act</emphasis> fázisban annyi a különbség, hogy most <literal>ValidationProblemDetails</literal> objektumot várunk a válaszban.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Act
var response = await client.PostAsJsonAsync("/api/products", dto, _serializerOptions);
var p = await response.Content
            .ReadFromJsonAsync&lt;ValidationProblemDetails&gt;(_serializerOptions);</programlisting>
<simpara>Az <emphasis>Assert</emphasis> fázisban pedig a HTTP státuszkódot és a <literal>ProblemDetails</literal> tartalmára vizsgáljunk.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">// Assert
response.StatusCode.Should().Be(HttpStatusCode.BadRequest);

p.Status.Should().Be(400);
p.Errors.Should().HaveCount(1);
p.Errors.Should().ContainKey(nameof(Product.Name));
p.Errors[nameof(Product.Name)].Should().ContainSingle(expectedError);</programlisting>
<simpara>Próbáljuk ki a menu:Test[Run All Test] menüpont segítségével. Figyeljük meg a tesztek hierarchiáját is, a POST művelethez kapcsolódó tesztek egy csoportba lettek összefogva.</simpara>
<tip><simpara>Észrevehetjük, hogy a tranzakciókezeléssel kapcsolatos kódot duplikáltuk, ennek elkerülésére például <ulink url="https://github.com/xunit/samples.xunit/blob/main/AutoRollbackExample/AutoRollbackAttribute.cs">például tesztfüggvényre tehető attribútumot</ulink> vezethetünk be.</simpara></tip>
</section>
</section>
<section id="_naplózás">
<title>Naplózás</title>
<simpara>A tesztek üzeneteket naplózhatnak egy speciális tesztkimenetre. Ehhez minden tesztosztály példány kap(hat) egy saját <literal>ITestOutputHelper</literal> példányt a konstruktoron keresztül. Vezessük be az új konstruktorparamétert a tesztosztályban és az ősosztályában is.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">    private readonly ITestOutputHelper _testOutput;

/**/public ProductControllerTests(CustomWebApplicationFactory appFactory
        , ITestOutputHelper output)
/**/{
        //...
        _testOutput = output;
/**/}

//... Post beágyazott típus konstruktora

/**/public Post(CustomWebApplicationFactory appFactory
                , ITestOutputHelper output)
        : base(appFactory, output) //plusz paraméter átadása
/**/{ }</programlisting>
<simpara>Próbaképp írjunk ki egy üzenetet a <literal>ProductControllerTests</literal> konstruktorában.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/_testOutput = output;
    output.WriteLine("ProductControllerTests ctor");</programlisting>
<simpara>Ellenőrizzük, hogy a tesztek lefuttatása után <emphasis>Test Explorer</emphasis>-ben megjelennek-e az üzenetek a <ulink url="https://learn.microsoft.com/en-us/visualstudio/test/run-unit-tests-with-test-explorer?view=vs-2022#view-test-details"><emphasis>Test Detail Summary</emphasis></ulink> ablakrész <emphasis>Standard output</emphasis> szekciójában. Ebből láthatjuk, hogy minden tesztfüggvény, sőt minden tesztfüggvény változat (a <emphasis>Theory</emphasis> minden bemeneti adatsora egy külön változat) meghívásakor lefut a konstruktor.</simpara>
<simpara>Ugyanerre a kimenetre kössük rá a szerveroldali naplózást, hogy a tesztek lefutása mellett ezek a naplóüzenetek is megjelenjenek. Ehhez telepítsünk egy segédcsomagot a tesztprojektbe.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;PackageReference Include="MartinCostello.Logging.XUnit" Version="0.3.0" /&gt;</programlisting>
<simpara>A <literal>ProductControllerTests</literal> konstruktorában kössük össze a két paramétert, a <literal>CustomWebApplicationFactory</literal> és az <literal>ITestOutputHelper</literal> példányt a fenti segédcsomag (<literal>AddXUnit</literal> metódus) segítségével. A tesztszerver naplózó alrendszerének adjuk meg kimenetként az xUnit tesztkimenetét.</simpara>
<programlisting language="csharp" linenumbering="unnumbered">/**/_appFactory = appFactory
        .WithWebHostBuilder(builder =&gt;
        {
            builder.ConfigureLogging(logging =&gt;
            {
                logging.ClearProviders();
                logging.AddXUnit(output);
            });
        });</programlisting>
<simpara>Ellenőrizzük, hogy a tesztek lefuttatása után <emphasis>Test Explorer</emphasis>-ben megjelennek-e a szerveroldali üzenetek is.</simpara>
<simpara>A végállapot elérhető a kapcsolódó GitHub repo <ulink url="https://github.com/bmeaut/WebApiLab/tree/net6-test-megoldas">net6-test-megoldas ágán</ulink>.</simpara>
</section>
</article>
